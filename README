NAME
    Devel::MonkeyPatch::Sub - Does the dirty work of monkey-patching subs
    for you.

SYNOPSIS
      # wrap a method
      wrap_sub Foo::Bar::some_sub => sub {
        my $self = shift;

        # do something

        return $self->original::method(@_);
      };

      # install a new method
      replace_sub Foo::Bar::some_sub => sub {
        my $self = shift;

        # do something
      };

DISCLAIMER
    This is ALPHA SOFTWARE. Use at your own risk. Features may change.

DESCRIPTION
    Monkey-patching (or guerilla-patching or duck-punching or whatever you
    call it) is the process of changing the code at runtime. The most
    prominent example is replacing or wrapping methods of a class.

  Hand-coded monkey-patching
    The usual idom to wrap a method 'in place':

      use Sub::Name;

      {
        no strict 'refs';
        no warnings 'redefine';

        my $orig_method = \&Foo::Bar::some_sub;
        *Foo::Bar::some_sub = subname 'Foo::Bar::some_sub' => sub {
          use strict;
          use warnings;

          my $self = shift;

          # do something

          return $self->$orig_method(@_);
        };
      }

    Now, there are two problems with that:

    *   It contains a lot of duplication (look, "Foo::Bar::some_sub" is
        written 3 times) and the whole construct is a heavy boilerplate.

    *   If by accident you forget to switch back on the strictures and
        warnings, more code is compiled and run under "no strict 'refs'"
        (and "no warnings 'redefine'") than should be.

    This module tries to provide a more convenient and expressive interface
    for wrapping (or simply adding/replacing) methods 'in place'.

  Differences from Aspect and Hook::LexWrap
    The Aspect module gives you a full-fledged AOP API where you can easily
    wrap even dozens of subroutines in one call, with clear and nice syntax.
    It is much more powerful and flexible when selecting what to wrap. Its
    model to run code before or after the original method and modify values
    is more elegant. It even tweaks "caller" in CORE to make things look
    better. Still, it has these disadvantages over Devel::MonkeyPatch::Sub:

    *   With Aspect you can run any code before or after the original
        method, but if the original method throws an exception, you cannot
        currently catch it.

    *   With Aspect the "before" in Aspect and "after" in Aspect advices are
        in separate scopes than the call to the original method, so you
        cannot localize variables for the duration of the call to the
        original subroutine.

    *   With Aspect you cannot currently add a new method to a class.

    Devel::MonkeyPatch::Sub is also more lightweight than Aspect.

    Using Hook::LexWrap (which Aspect is based on) shares the above
    disadvantages with Aspect.

VERSION
    Version 0.01

EXPORT
    No methods are exported by default. You can import replace_sub and
    "wrap_sub" if you want to.

    "original::method" and original::sub are unconditionally created in the
    original package (not an original idea to use that namespace for
    anything sensible, so I hope it won't clash with your code).

METHODS
  original::method(LIST)
    Calls the original method (ie. that was in effect before the
    monkey-patching) with LIST as parameters. Returns the value returned by
    that method.

    Should only be called from inside the subroutine that is installed by
    "wrap_sub" (otherwise the behaviour is undefined).

  original::sub(LIST)
    The same as "original::method".

  replace_sub(NAME|GLOB, CODE)
    Replaces the subroutine identified by NAME|GLOB with CODE (if a sub with
    that name alreay existed), or installs CODE as a new sub with the given
    name (if no such sub existed before).

    The first parameter (NAME or GLOB) that identifies the sub to be
    replaced/created can be a typeglob, a bareword or a string. If it is an
    unqualified name, it is qualified with the package name of the caller of
    "replace_sub".

    All the subroutines installed will have the fully qualified name of the
    subroutine they're replacing assigned to via "subname" in Sub::Name. The
    prototype of the new subroutine is set to that of the original
    subroutine (if it had any prototype).

    Returns: reference to the new sub (ie. what GLOB|NAME will refer to
    after the patching)

    Note: you cannot not call "$self->original::method(@_)" from subroutines
    installed via "replace_sub". (The behaviour of "original::method" is
    undefined in subroutines created via "replace_sub".) If you need
    "original::method", use "wrap_sub" instead.

  wrap_sub(NAME|GLOB, CODE)
    Replaces the subroutine identified by NAME|GLOB with CODE (if a sub with
    that name alreay existed), or installs CODE as a new sub with the given
    name (if no such sub existed before).

    You can call the original sub from CODE via the
    "$self->original::method(@_)" syntax (see "original::method"). If the
    sub did not exist before wrapping it, "$self->original::method(@_)" will
    be simply a no-op.

    The first parameter (NAME or GLOB) that identifies the sub to be
    replaced/created can be a typeglob, a bareword or a string. If it is an
    unqualified name, it is qualified with the package name of the caller of
    "replace_sub".

    All the subroutines installed will have the fully qualified name of the
    subroutine they're replacing assigned to via "subname" in Sub::Name. The
    prototype of the new subroutine is set to that of the original
    subroutine (if it had any prototype).

    Returns: reference to the new sub (ie. what GLOB|NAME will refer to
    after the patching)

    Note: If you do not intend to call "$self->original::method(@_)" from
    CODE, you should use the faster "replace_sub" instead.

EXAMPLES
      # create or replace a new sub
      replace_sub Foo::Bar::some_sub => sub {
        print "hello\n";
      };

      # wrap an existing method
      wrap_sub Foo::Bar::some_sub => sub {
        my $self = @_;

        $_[0] = 42;

        $self->original::method(@_);
      };

      # wrap an existing function
      wrap_sub Foo::Bar::some_sub => sub {
        $_[0] = 42;

        original::sub(@_);
      };


      # wrap a method by name
      wrap_sub 'Foo::Bar::some_sub' => sub {
        ...
      };

      # wrap a method by name (bareword)
      wrap_sub Foo::Bar::some_sub => sub {
        ...
      };

      # wrap a method by typeglob
      wrap_sub *Foo::Bar::some_sub => sub {
        ...
      };


      # wrap a method with dynamic scope
      local *Foo::Bar::some_sub = \&Foo::Bar::some_sub;
      wrap_sub *Foo::Bar::some_sub => sub {
        ...
      };


      # wrap a method in a context-preserving way (ie. it will work with
      # context-sensitive methods)
      use Context::Preserve;
      wrap_sub Foo::Bar::some_sub => sub {
        my $self = shift;
        my $args = \@_;

        return preserve_context { $self->original::method(@$args) }
          after => sub {
            my ($self) = @_;

            $self->set_something(42);
          };
      };

BUGS, CAVEATS AND NOTES
  Performance
    The current implementation of "wrap_sub" uses 2 extra function calls
    compared to the hand-coded version outlined in "DESCRIPTION" (which in
    turn uses 1 extra function call compared to the unwrapped function). You
    may or may not care about that. Not measured the actual effect of it
    yet.

    "replace_sub" is exempt of this defect, it has no runtime penalty
    compared to the hand-coded version.

  Monkey-patching is next to evil
    Monkey-patching can save the day (and did it several times), but is a
    dangerous device. Extensively replacing/wrapping others' methods without
    serious reasons is not considered to be a good practice. Try to stand
    the temptation, and do not do it unless you really have to. See eg.
    <http://en.wikipedia.org/wiki/Monkey_patching#Pitfalls>.

  Use Aspect for AOP
    If you want to do some real Aspect Oriented Programming (AOP) instead of
    just wrapping/replacing/adding some random method, you're better off
    with using the Aspect module. See also "Differences from Aspect".

  caller() shows your wrapper
    Unlike Hook::LexWrap or Aspect, Devel::MonkeyPatch::Sub does not (yet)
    override "caller". The problem is that some subroutines expect that they
    are called by the actual user code, and then they will behave less
    usefully if there's a wrapper inbetween.

  subname() and set_prototype() is called even on named subs
    Currently "subname" in Sub::Name is called on CODE even if CODE is a
    reference to a named subroutine, which is clearly the wrong behaviour
    (it should skip the "subname" in Sub::Name call in that case). The same
    goes for the "set_prototype" in Sub::Prototype call.

SEE ALSO
    Sub::Name, Aspect, Hook::LexWrap, Context::Preserve

SUPPORT
    Please submit bugs to the CPAN RT system at
    http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AMonkeyPatch%3A
    %3ASub or via email at bug-devel-monkeypatch-sub@rt.cpan.org.

AUTHOR
    Norbert Buchmüller <norbi@nix.hu>

COPYRIGHT
    Copyright 2009 Norbert Buchmüller.

    This program is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

